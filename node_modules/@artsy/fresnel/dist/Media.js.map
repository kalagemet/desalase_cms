{"version":3,"sources":["../src/Media.tsx"],"names":["createMedia","config","mediaQueries","MediaQueries","breakpoints","interactions","DynamicResponsive","MediaContext","React","createContext","displayName","MediaContextProvider","disableDynamicMediaQueries","onlyMatch","children","dynamicResponsiveMediaQueries","mediaQueryTypes","matches","matchingMediaQueries","Object","keys","filter","key","Media","props","validateProps","className","passedClassName","interaction","breakpointProps","at","largestBreakpoint","ownerName","owner","_reactInternalFiber","_debugOwner","type","name","err","console","warn","breakpoint","renderChildren","undefined","shouldRenderMediaQuery","Function","Component","createMediaStyle","toStyle","SortedBreakpoints","sortedBreakpoints","findBreakpointAtWidth","findBreakpointsForWidths","valuesWithBreakpointProps","MutuallyExclusiveProps","validKeys","selectedProps","prop","includes","length","Error","join"],"mappings":"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","sourcesContent":["// tslint:disable:jsdoc-format\n\nimport React from \"react\"\nimport { createResponsiveComponents } from \"./DynamicResponsive\"\nimport { MediaQueries } from \"./MediaQueries\"\nimport { intersection, propKey, createClassName } from \"./Utils\"\nimport { BreakpointConstraint } from \"./Breakpoints\"\n\n/**\n * A render prop that can be used to render a different container element than\n * the default `div`.\n *\n * @see {@link MediaProps.children}.\n */\nexport type RenderProp = (\n  className: string,\n  renderChildren: boolean\n) => React.ReactNode\n\n// TODO: All of these props should be mutually exclusive. Using a union should\n//       probably be made possible by https://github.com/Microsoft/TypeScript/pull/27408.\nexport interface MediaBreakpointProps<BreakpointKey = string> {\n  /**\n   * Children will only be shown if the viewport matches the specified\n   * breakpoint. That is, a viewport width that’s higher than the configured\n   * breakpoint value, but lower than the value of the next breakpoint, if any\n   * larger breakpoints exist at all.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width between 0 and 768\n     <Media at=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width between 768 and 1024\n     <Media at=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width over 1024\n     <Media at=\"md\">ohai</Media>\n     ```\n   *\n   */\n  at?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is smaller than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n    // Matches a viewport that has a width from 0 to 767\n     <Media lessThan=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media lessThan=\"md\">ohai</Media>\n     ```\n   *\n   */\n  lessThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThan=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThan=\"sm\">ohai</Media>\n     ```\n   *\n   */\n  greaterThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater or equal to the\n   * specified breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to infinity\n     <Media greaterThanOrEqual=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThanOrEqual=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThanOrEqual=\"md\">ohai</Media>\n     ```\n   *\n   */\n  greaterThanOrEqual?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is between the specified\n   * breakpoints. That is, a viewport width that’s higher than or equal to the\n   * small breakpoint value, but lower than the value of the large breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to 767\n     <Media between={[\"xs\", \"sm\"]}>ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media between={[\"xs\", \"md\"]}>ohai</Media>\n     ```\n   *\n   */\n  between?: [BreakpointKey, BreakpointKey]\n}\n\nexport interface MediaProps<BreakpointKey, Interaction>\n  extends MediaBreakpointProps<BreakpointKey> {\n  /**\n   * Children will only be shown if the interaction query matches.\n   *\n   * @example\n\n     ```tsx\n     // With interactions defined like these\n     { hover: \"(hover: hover)\" }\n\n     // Matches an input device that is capable of hovering\n     <Media interaction=\"hover\">ohai</Media>\n     ```\n   */\n  interaction?: Interaction\n\n  /**\n   * The component(s) that should conditionally be shown, depending on the media\n   * query matching.\n   *\n   * In case a different element is preferred, a render prop can be provided\n   * that receives the class-name it should use to have the media query styling\n   * applied.\n   *\n   * Additionally, the render prop receives a boolean that indicates wether or\n   * not its children should be rendered, which will be `false` if the media\n   * query is not included in the `onlyMatch` list. Use this flag if your\n   * component’s children may be expensive to render and you want to avoid any\n   * unnecessary work.\n   * (@see {@link MediaContextProviderProps.onlyMatch} for details)\n   *\n   * @example\n   *\n     ```tsx\n     const Component = () => (\n       <Media greaterThan=\"xs\">\n         {(className, renderChildren) => (\n           <span className={className}>\n             {renderChildren && \"ohai\"}\n           </span>\n         )}\n       </Media>\n     )\n     ```\n   *\n   */\n  children: React.ReactNode | RenderProp\n\n  /**\n   * Additional classNames to passed down and applied to Media container\n   */\n  className?: string\n}\n\nexport interface MediaContextProviderProps<M> {\n  /**\n   * This list of breakpoints and interactions can be used to limit the rendered\n   * output to these.\n   *\n   * For instance, when a server knows for some user-agents that certain\n   * breakpoints will never apply, omitting them altogether will lower the\n   * rendered byte size.\n   */\n  onlyMatch?: M[]\n\n  /**\n   * Disables usage of browser MediaQuery API to only render at the current\n   * breakpoint.\n   *\n   * Use this with caution, as disabling this means React components for all\n   * breakpoints will be mounted client-side and all associated life-cycle hooks\n   * will be triggered, which could lead to unintended side-effects.\n   */\n  disableDynamicMediaQueries?: boolean\n}\n\nexport interface CreateMediaConfig {\n  /**\n   * The breakpoint definitions for your application. Width definitions should\n   * start at 0.\n   *\n   * @see {@link createMedia}\n   */\n  breakpoints: { [key: string]: number }\n\n  /**\n   * The interaction definitions for your application.\n   */\n  interactions?: { [key: string]: string }\n}\n\nexport interface CreateMediaResults<BreakpointKey, Interactions> {\n  /**\n   * The React component that you use throughout your application.\n   *\n   * @see {@link MediaBreakpointProps}\n   */\n  Media: React.ComponentType<MediaProps<BreakpointKey, Interactions>>\n\n  /**\n   * The React Context provider component that you use to constrain rendering of\n   * breakpoints to a set list and to enable client-side dynamic constraining.\n   *\n   * @see {@link MediaContextProviderProps}\n   */\n  MediaContextProvider: React.ComponentType<\n    MediaContextProviderProps<BreakpointKey | Interactions>\n  >\n\n  /**\n   * Generates a set of CSS rules that you should include in your application’s\n   * styling to enable the hiding behaviour of your `Media` component uses.\n   */\n  createMediaStyle(breakpointKeys?: BreakpointConstraint[]): string\n\n  /**\n   * A list of your application’s breakpoints sorted from small to large.\n   */\n  SortedBreakpoints: BreakpointKey[]\n\n  /**\n   * Creates a list of your application’s breakpoints that support the given\n   * widths and everything in between.\n   */\n  findBreakpointsForWidths(\n    fromWidth: number,\n    throughWidth: number\n  ): BreakpointKey[] | undefined\n\n  /**\n   * Finds the breakpoint that matches the given width.\n   */\n  findBreakpointAtWidth(width: number): BreakpointKey | undefined\n\n  /**\n   * Maps a list of values for various breakpoints to props that can be used\n   * with the `Media` component.\n   *\n   * The values map to corresponding indices in the sorted breakpoints array. If\n   * less values are specified than the number of breakpoints your application\n   * has, the last value will be applied to all subsequent breakpoints.\n   */\n  valuesWithBreakpointProps<SizeValue>(\n    values: SizeValue[]\n  ): Array<[SizeValue, MediaBreakpointProps<BreakpointKey>]>\n}\n\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your application’s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\nexport function createMedia<\n  MediaConfig extends CreateMediaConfig,\n  BreakpointKey extends keyof MediaConfig[\"breakpoints\"],\n  Interaction extends keyof MediaConfig[\"interactions\"]\n>(config: MediaConfig): CreateMediaResults<BreakpointKey, Interaction> {\n  const mediaQueries = new MediaQueries<BreakpointKey>(\n    config.breakpoints,\n    config.interactions || {}\n  )\n\n  const DynamicResponsive = createResponsiveComponents()\n\n  const MediaContext = React.createContext<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  >({})\n  MediaContext.displayName = \"Media.Context\"\n\n  const MediaContextProvider: React.SFC<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  > = ({ disableDynamicMediaQueries, onlyMatch, children }) => {\n    if (disableDynamicMediaQueries) {\n      return (\n        <MediaContext.Provider\n          value={{\n            onlyMatch,\n          }}\n        >\n          {children}\n        </MediaContext.Provider>\n      )\n    } else {\n      return (\n        <DynamicResponsive.Provider\n          mediaQueries={mediaQueries.dynamicResponsiveMediaQueries}\n          initialMatchingMediaQueries={intersection(\n            mediaQueries.mediaQueryTypes,\n            onlyMatch\n          )}\n        >\n          <DynamicResponsive.Consumer>\n            {matches => {\n              const matchingMediaQueries = Object.keys(matches).filter(\n                key => matches[key]\n              )\n              return (\n                <MediaContext.Provider\n                  value={{\n                    onlyMatch: intersection(matchingMediaQueries, onlyMatch),\n                  }}\n                >\n                  {children}\n                </MediaContext.Provider>\n              )\n            }}\n          </DynamicResponsive.Consumer>\n        </DynamicResponsive.Provider>\n      )\n    }\n  }\n\n  const Media = class extends React.Component<\n    MediaProps<BreakpointKey, Interaction>\n  > {\n    constructor(props) {\n      super(props)\n      validateProps(props)\n    }\n\n    static defaultProps = {\n      className: \"\",\n    }\n\n    render() {\n      const props = this.props\n      return (\n        <MediaContext.Consumer>\n          {({ onlyMatch } = {}) => {\n            let className: string | null\n            const {\n              children,\n              className: passedClassName,\n              interaction,\n              ...breakpointProps\n            } = props\n            if (props.interaction) {\n              className = createClassName(\"interaction\", props.interaction)\n            } else {\n              if (props.at) {\n                const largestBreakpoint =\n                  mediaQueries.breakpoints.largestBreakpoint\n                if (props.at === largestBreakpoint) {\n                  // TODO: We should look into making React’s __DEV__ available\n                  //       and have webpack completely compile these away.\n                  let ownerName = null\n                  try {\n                    const owner = (this as any)._reactInternalFiber._debugOwner\n                      .type\n                    ownerName = owner.displayName || owner.name\n                  } catch (err) {\n                    // no-op\n                  }\n\n                  console.warn(\n                    \"[@artsy/fresnel] \" +\n                      \"`at` is being used with the largest breakpoint. \" +\n                      \"Consider using `<Media greaterThanOrEqual=\" +\n                      `\"${largestBreakpoint}\">\\` to account for future ` +\n                      `breakpoint definitions outside of this range.${\n                        ownerName\n                          ? ` It is being used in the ${ownerName} component.`\n                          : \"\"\n                      }`\n                  )\n                }\n              }\n\n              const type = propKey(breakpointProps)\n              const breakpoint = breakpointProps[type]!\n              className = createClassName(type, breakpoint)\n            }\n\n            const renderChildren =\n              onlyMatch === undefined ||\n              mediaQueries.shouldRenderMediaQuery(\n                { ...breakpointProps, interaction },\n                onlyMatch\n              )\n\n            if (props.children instanceof Function) {\n              return props.children(className, renderChildren)\n            } else {\n              return (\n                <div\n                  className={`fresnel-container ${className} ${passedClassName}`}\n                  suppressHydrationWarning={!renderChildren}\n                >\n                  {renderChildren ? props.children : null}\n                </div>\n              )\n            }\n          }}\n        </MediaContext.Consumer>\n      )\n    }\n  }\n\n  return {\n    Media,\n    MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: [...mediaQueries.breakpoints.sortedBreakpoints],\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps:\n      mediaQueries.breakpoints.valuesWithBreakpointProps,\n  }\n}\n\nconst MutuallyExclusiveProps: string[] = MediaQueries.validKeys()\n\nfunction validateProps(props) {\n  const selectedProps = Object.keys(props).filter(prop =>\n    MutuallyExclusiveProps.includes(prop)\n  )\n  if (selectedProps.length < 1) {\n    throw new Error(`1 of ${MutuallyExclusiveProps.join(\", \")} is required.`)\n  } else if (selectedProps.length > 1) {\n    throw new Error(\n      `Only 1 of ${selectedProps.join(\", \")} is allowed at a time.`\n    )\n  }\n}\n"],"file":"Media.js"}