{"version":3,"sources":["../src/Breakpoints.ts"],"names":["breakpointKey","breakpoint","Array","isArray","join","BreakpointConstraint","Breakpoints","at","lessThan","greaterThan","greaterThanOrEqual","between","breakpoints","fromWidth","throughWidth","fromBreakpoint","findBreakpointAtWidth","undefined","throughBreakpoint","_sortedBreakpoints","slice","indexOf","width","find","i","nextBreakpoint","_breakpoints","values","max","length","valueBreakpoints","lastTuple","forEach","value","push","map","props","Object","keys","sort","a","b","breakpointAndValue","betweenCombinations","reduce","acc","b1","b2","_mediaQueries","_createBreakpointQueries","validKeys","selectedMediaQueries","mediaQueries","query","entries","type","queries","breakpointProps","onlyRenderAt","_normalizeProps","lowestAllowedWidth","Math","min","_findNextBreakpoint","highestAllowedWidth","toWidth","allowedWidths","fromIndex","to","Error","JSON","stringify","key","forBreakpoints","set","_createBreakpointQuery","Map","from","k","v"],"mappings":"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","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type BreakpointConstraintKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<SizeValue, BreakpointKey> = [\n  SizeValue,\n  MediaBreakpointProps<BreakpointKey>\n]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\nexport enum BreakpointConstraint {\n  at = \"at\",\n  lessThan = \"lessThan\",\n  greaterThan = \"greaterThan\",\n  greaterThanOrEqual = \"greaterThanOrEqual\",\n  between = \"between\",\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<BreakpointKey extends string> {\n  static validKeys() {\n    return [\n      BreakpointConstraint.at,\n      BreakpointConstraint.lessThan,\n      BreakpointConstraint.greaterThan,\n      BreakpointConstraint.greaterThanOrEqual,\n      BreakpointConstraint.between,\n    ]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: Record<string, number>\n  private _mediaQueries: Record<BreakpointConstraint, Map<string, string>>\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      [BreakpointConstraint.at]: this._createBreakpointQueries(\n        BreakpointConstraint.at,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.lessThan]: this._createBreakpointQueries(\n        BreakpointConstraint.lessThan,\n        this._sortedBreakpoints.slice(1)\n      ),\n      [BreakpointConstraint.greaterThan]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThan,\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      [BreakpointConstraint.greaterThanOrEqual]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThanOrEqual,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.between]: this._createBreakpointQueries(\n        BreakpointConstraint.between,\n        betweenCombinations\n      ),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as BreakpointKey[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(\n      this._mediaQueries[BreakpointConstraint.at].entries()\n    ).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {})\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as BreakpointKey[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as BreakpointKey[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as BreakpointKey | undefined\n  }\n\n  public toRuleSets(keys = Breakpoints.validKeys()) {\n    const selectedMediaQueries = keys.reduce(\n      (mediaQueries, query) => {\n        mediaQueries[query] = this._mediaQueries[query]\n        return mediaQueries\n      },\n      {} as Record<BreakpointConstraint, Map<string, string>>\n    )\n\n    return Object.entries(selectedMediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <SizeValue>(\n    values: SizeValue[]\n  ): Array<ValueBreakpointPropsTuple<SizeValue, BreakpointKey>> => {\n    type ValueBreakpoints = [SizeValue, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<\n        SizeValue,\n        BreakpointKey\n      >\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 1}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 1}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: BreakpointConstraintKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n"],"file":"Breakpoints.js"}